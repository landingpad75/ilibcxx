#pragma once

extern "C" {
    #include <string.h>
    #include <stdlib.h>
}

namespace std {

class string {
private:
    char* data_;
    size_t size_;
    size_t capacity_;
    
    void reserve_internal(size_t new_cap) {
        if (new_cap <= capacity_) return;
        
        char* new_data = new char[new_cap + 1];
        if (data_) {
            memcpy(new_data, data_, size_);
            delete[] data_;
        }
        data_ = new_data;
        data_[size_] = '\0';
        capacity_ = new_cap;
    }
    
public:
    string() : data_(nullptr), size_(0), capacity_(0) {
        reserve_internal(16);
    }
    
    string(const char* str) : data_(nullptr), size_(0), capacity_(0) {
        if (str) {
            size_ = strlen(str);
            reserve_internal(size_);
            memcpy(data_, str, size_);
            data_[size_] = '\0';
        } else {
            reserve_internal(16);
        }
    }
    
    string(const string& other) : data_(nullptr), size_(0), capacity_(0) {
        reserve_internal(other.size_);
        size_ = other.size_;
        memcpy(data_, other.data_, size_);
        data_[size_] = '\0';
    }
    
    string(string&& other) noexcept : data_(other.data_), size_(other.size_), capacity_(other.capacity_) {
        other.data_ = nullptr;
        other.size_ = 0;
        other.capacity_ = 0;
    }
    
    ~string() {
        if (data_) delete[] data_;
    }
    
    string& operator=(const string& other) {
        if (this != &other) {
            reserve_internal(other.size_);
            size_ = other.size_;
            memcpy(data_, other.data_, size_);
            data_[size_] = '\0';
        }
        return *this;
    }
    
    string& operator=(string&& other) noexcept {
        if (this != &other) {
            if (data_) delete[] data_;
            data_ = other.data_;
            size_ = other.size_;
            capacity_ = other.capacity_;
            other.data_ = nullptr;
            other.size_ = 0;
            other.capacity_ = 0;
        }
        return *this;
    }
    
    string& operator=(const char* str) {
        size_ = str ? strlen(str) : 0;
        reserve_internal(size_);
        if (str) memcpy(data_, str, size_);
        data_[size_] = '\0';
        return *this;
    }
    
    const char* c_str() const { return data_ ? data_ : ""; }
    size_t size() const { return size_; }
    size_t length() const { return size_; }
    bool empty() const { return size_ == 0; }
    
    char& operator[](size_t pos) { return data_[pos]; }
    const char& operator[](size_t pos) const { return data_[pos]; }
    
    void push_back(char c) {
        if (size_ + 1 >= capacity_) {
            reserve_internal(capacity_ * 2);
        }
        data_[size_++] = c;
        data_[size_] = '\0';
    }
    
    void pop_back() {
        if (size_ > 0) {
            data_[--size_] = '\0';
        }
    }
    
    void clear() {
        size_ = 0;
        if (data_) data_[0] = '\0';
    }
    
    string& operator+=(const string& other) {
        reserve_internal(size_ + other.size_);
        memcpy(data_ + size_, other.data_, other.size_);
        size_ += other.size_;
        data_[size_] = '\0';
        return *this;
    }
    
    string& operator+=(const char* str) {
        if (str) {
            size_t len = strlen(str);
            reserve_internal(size_ + len);
            memcpy(data_ + size_, str, len);
            size_ += len;
            data_[size_] = '\0';
        }
        return *this;
    }
    
    string& operator+=(char c) {
        push_back(c);
        return *this;
    }
    
    bool operator==(const string& other) const {
        return size_ == other.size_ && memcmp(data_, other.data_, size_) == 0;
    }
    
    bool operator==(const char* str) const {
        return str && strcmp(data_, str) == 0;
    }
    
    bool operator!=(const string& other) const { return !(*this == other); }
    bool operator!=(const char* str) const { return !(*this == str); }
};

inline string operator+(const string& lhs, const string& rhs) {
    string result = lhs;
    result += rhs;
    return result;
}

inline string operator+(const string& lhs, const char* rhs) {
    string result = lhs;
    result += rhs;
    return result;
}

}
